{"version":3,"sources":["../src/data-converter.js"],"names":["moment","aggregate","getFragment","createConverter","aggregateType","fragmentType","prepareData","from","to","fragment","data","fromUtc","utc","toUtc","groupData","dataList","container","targets","_","map","forEach","target","datapoints","filter","value","timestamp","bucketTimestamp","getBucketTimestamp","values","push","aggregateData","aggregateFunc","result","createBucket","buckets","bucket","size","firstTimestamp","first","Object","forOwn","arr","length","normalizeData","obj","sum","mapValues","rankData","sortedValues","sortBy","indexOf","convertData","processingMode","agg","eq","allValues","flatten","stats","min","max"],"mappings":"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","file":"data-converter.js","sourcesContent":["import moment from 'moment';\n\nimport { aggregate } from './aggregates';\nimport { getFragment } from './fragments';\n\nconst createConverter = (aggregateType, fragmentType) => {\n\n  const prepareData = (from, to, fragment) => {\n    const data = {};\n    const fromUtc = moment.utc(from);\n    const toUtc = moment.utc(to);\n    // timeUtc = timeUtc.add(1, 'day')\n    return {\n      data,\n      from: fromUtc,\n      to: toUtc\n    };\n  };\n\n  const groupData = (from, to, fragment, dataList) => {\n    const container = prepareData(from, to, fragment);\n    const targets = _.map(dataList, 'target');\n    container.targets = targets;\n\n    dataList.forEach(({ target, datapoints }) => {\n      datapoints\n        .filter(([value]) => value !== null)\n        .forEach(([value, timestamp]) => {\n          const bucketTimestamp = fragment.getBucketTimestamp(timestamp);\n          if (!(bucketTimestamp in container.data)) {\n            container.data[bucketTimestamp] = {\n              timestamp: bucketTimestamp,\n              values: {},\n            };\n          }\n          if (!(target in container.data[bucketTimestamp].values)) {\n            container.data[bucketTimestamp].values[target] = [];\n          }\n          container.data[bucketTimestamp].values[target].push(value);\n        });\n    });\n\n    return container;\n  };\n\n  const aggregateData = (from, to, fragment, container) => {\n    const data = container.data;\n    const aggregateFunc = aggregate(aggregateType);\n    const result = [];\n\n    const createBucket = (timestamp) => ({\n      timestamp,\n      buckets: {}\n    });\n\n    // let bucket = createBucket(moment(from).startOf('day'));\n    let bucket;\n    if (data && _.size(data) > 0) {\n      const firstTimestamp = _.first(_.values(data))['timestamp'];\n      bucket = createBucket(firstTimestamp);\n    }\n\n    Object.values(data).forEach(({ timestamp, values }) => {\n      if (timestamp < bucket.timestamp) { return; }\n\n      const bucketTimestamp = fragment.getBucketTimestamp(timestamp);\n      if (bucket.timestamp != bucketTimestamp) {\n        result.push({ ...bucket });\n        bucket = createBucket(bucketTimestamp);\n      }\n\n      _.forOwn(values, function(arr, target) {\n        const value = arr.length > 0\n          ? aggregateFunc(arr)\n          : null;\n\n        bucket.buckets[target] = value;\n      });\n    });\n\n    result.push({ ...bucket });\n\n    return result;\n  };\n\n  const normalizeData = (data) => {\n    return _.map(data, function (obj) {\n      const values = _.values(obj.buckets);\n      const sum = _.sum(values);\n      // const sortedValues = _.sortBy(values);\n\n      obj.buckets = _.mapValues(obj.buckets, value => value/sum\n        // function(value) {\n        //   const rank = values.length - _.sortedIndexOf(sortedValues, value);\n        //   if (rank < 5) {\n        //     return value/sum;\n        //   } else {\n        //     return 0;\n        //   }\n        // }\n      );\n\n      return obj;\n    });\n  };\n\n  const rankData = (data) => {\n    return _.map(data, function (obj) {\n\n\n      const sortedValues = _.sortBy(_.values(obj.buckets));\n\n      obj.buckets = _.mapValues(obj.buckets, function(value) {\n        return _.indexOf(sortedValues, value);\n      });\n\n      return obj;\n    });\n  };\n\n  const convertData = (from, to, dataList, processingMode) => {\n    const fragment = getFragment(fragmentType);\n    const container = groupData(from, to, fragment, dataList);\n    let agg = aggregateData(from, to, fragment, container);\n    if (_.eq(processingMode, 'normalize')) { agg = normalizeData(agg); }\n    else if (_.eq(processingMode, 'rank')) {agg = rankData(agg);}\n    const allValues = _.flatten(_.map(agg, obj => _.values(obj.buckets)));\n    const data = {\n      data: agg,\n      stats: {\n        min: _.min(allValues),\n        max: _.max(allValues)\n      }\n    };\n\n    return {\n      ...container,\n      ...data\n    };\n  };\n\n  return {\n    convertData\n  };\n};\n\nexport default createConverter;\n"]}